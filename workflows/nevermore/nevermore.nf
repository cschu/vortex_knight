#!/usr/bin/env nextflow

nextflow.enable.dsl=2

include { qc_bbduk } from "../../modules/nevermore/qc/bbduk"
include { qc_bbmerge } from "../../modules/nevermore/qc/bbmerge"
include { fastqc } from "../../modules/nevermore/qc/fastqc"
include { multiqc } from "../../modules/nevermore/qc/multiqc"
include { classify_sample } from "../../modules/nevermore/functions"

def merge_pairs = (params.merge_pairs || false)
def keep_orphans = (params.keep_orphans || false)


process concat_singles {
    input:
    tuple val(sample), path(reads)

    output:
    tuple val(sample), path("${sample}/${sample}.singles_R1.fastq.gz"), emit: reads

    script:
    """
    mkdir -p $sample
    cat ${reads} > ${sample}/${sample}.singles_R1.fastq.gz
    """
}


workflow nevermore_simple_preprocessing {

	take:

		fastq_ch

	main:

		fastqc(fastq_ch)

        multiqc(
            fastqc.out.reports.map { sample, report -> report }.collect(),
			"${projectDir}/config/multiqc.config"
        )

		qc_bbduk(fastq_ch, "${projectDir}/assets/adapters.fa")

	emit:

		main_reads_out = qc_bbduk.out.reads
		orphan_reads_out = qc_bbduk.out.orphans	

}


workflow nevermore_preprocessing {

	take:
		fastq_ch

	main:

		qc_bbduk(fastq_ch)
	
		/* decide if we want to keep orphan reads generated by paired-end qc */
	
		orphan_reads_ch = qc_bbduk.out.orphans
	
		/* get the surviving paired-end reads from the qc */
	
		paired_reads_ch = qc_bbduk.out.reads
			.filter { it[1].size() == 2 }
	
		/* get the surviving single-end reads from the qc of single-end libraries (these are not orphans!) */
	
		singlelib_reads_ch = qc_bbduk.out.reads
			.filter { it[1].size() != 2 }
	
		paired_reads_ch.view()
	
		/* merge_pairs implies that we want to keep the merged reads, which are 'longer single-ends' */
	
		if (merge_pairs) {
	
			/* attempt to merge the paired-end reads */
	
			qc_bbmerge(paired_reads_ch)
	
			/* join the orphans (potentially empty, s. a.) and the merged reads as all are single-end */ 
	
			if (keep_orphans) {
				single_reads_ch = orphan_reads_ch
					.join(qc_bbmerge.out.merged, remainder: true)
					.map { sample, orphans, merged ->
						return (orphans != null) ? tuple(sample, [orphans, merged]) : tuple(sample, merged)
					}

			} else {

				single_reads_ch = qc_bbmerge.out.merged

			}
	
			/* concatenate the joined single-end read files */
	
			concat_singles(single_reads_ch)
	
			/* join un-merged reads and single end reads into a common channel for downstream analysis */
	
			paired_out_ch = qc_bbmerge.out.pairs
	
			single_out_ch = singlelib_reads_ch
				.concat(concat_singles.out.reads)
	
		} else {
		
			/* join the paired-end, single-end (from se-libraries) and, if desired, the orphans into a common channel */
	
			paired_out_ch = paired_reads_ch
	
			concat_singles(orphan_reads_ch)
	
			single_out_ch = singlelib_reads_ch

			if (keep_orphans) {

				single_out_ch = single_out_ch
					.concat(concat_singles.out.reads)

			}
	
		}

	emit:
		paired_reads = paired_out_ch
		single_reads = single_out_ch
}


workflow {

    fastq_ch = Channel
        .fromPath(params.input_dir + "/" + "**.{fastq,fq,fastq.gz,fq.gz}")
        .map { file ->
                def sample = file.name.replaceAll(/.(fastq|fq)(.gz)?$/, "")
                sample = sample.replaceAll(/_R?[12]$/, "")
                return tuple(sample, file)
        }
        .groupTuple(sort: true)
		.map { classify_sample(it[0], it[1]) }

	//fastq_ch.view()
	
	qc_bbduk(fastq_ch)

	qc_reads_ch = qc_bbduk.out.reads
		.map { classify_sample(it[0], it[1] ) }

	qc_reads_ch.view()


	//nevermore_preprocessing(fastq_ch)

	//nevermore_preprocessing.out.paired_reads.view()
	//nevermore_preprocessing.out.single_reads.view()

}
